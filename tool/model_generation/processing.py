# -*- coding: utf-8 -*-
"""
Created on Mon Jul 27 08:22:07 2020

@author: David
"""

import os
from collections import ChainMap
import numpy as np
from autosklearn.classification import AutoSklearnClassifier
from sklearn.model_selection import train_test_split
from ..utils.settings import load_object, load_object_with_params
from ..feature_extraction.writers.dict_to_dataframe import (
        DictToDataFrameWriter
)
from ..feature_extraction.features.utils.dictionary import prefix_dict_keys
from .autosklearn_hpo import DICT_HPO_ALG

import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


def prefix_files(file_list, prefix):
    return [os.path.join(prefix, f) if not os.path.dirname(f) else f
            for f in file_list]


def prefix_autosklean_params_dict(dictionary, prefix):
    new_dict = {}
    for key, value in dictionary.items():
        if not os.path.isabs(key):
            key = os.path.join(prefix, key)
        new_dict[key] = value
    return new_dict


def get_loader(config):
    info = config["MODEL_GENERATION_DATA_LOADER"]
    return load_object_with_params(info)


def extract_autosklearn_params(config, path):
    classifier_params = config["AUTOSKLEARN_PARAMS"]
    params_per_file = config.get("PER_DATASET_PARAMS", {}).get(path, {})
    classifier_params_per_file = params_per_file.get("classifier_params", {})
    classifier_params = ChainMap(classifier_params_per_file, classifier_params)
    fit_params = params_per_file.get("fit_params", {})
    return classifier_params, fit_params


def load_objects_list(extractor_list):
    return [load_object(extractor) for extractor in extractor_list]


def load_general_dict(general_dict):
    new_dict = {}
    for key, value in general_dict.items():
        new_dict[key] = load_object(value)
    return new_dict


def load_prediction_list(prediction_list):
    new_list = []
    for dictionary in prediction_list:
        new_dict = {}
        new_dict["prefix"] = dictionary.get("prefix", "")
        new_dict["estimator"] = load_object(dictionary["estimator"])
        new_dict["metrics"] = load_general_dict(dictionary["metrics"])
        new_dict["computation"] = load_object(dictionary["computation"])
        new_list.append(new_dict)
    return new_list


def load_extractors(extractor_dict):
    new_dict = {}
    new_dict["extractors"] = load_objects_list(
            extractor_dict.get("extractors", [])
    )
    new_dict["general"] = load_general_dict(extractor_dict.get("general", {}))
    new_dict["prediction"] = load_prediction_list(
                                      extractor_dict.get("prediction", []))
    return new_dict


class ModelGenerationManager:
    DICT_HPO_ALG = DICT_HPO_ALG

    def __init__(self, config):
        self.config = config
        self.files = config["MODEL_GENERATION_FILES_TO_LOAD"]
        self.loader = get_loader(config)
        self.hpo = config["AUTOSKLEARN_HPO"]
        self.info_extractors = load_extractors(config["MODEL_INFO_EXTRACTION"])
        self.output_file = config["INFO_OUTPUT_FILE"]
        self.writer = DictToDataFrameWriter(self.output_file)
        self.num_trials = config["NUM_OF_TRIALS"]
        obj = config.get("MODEL_POSTPROCESSING", None)
        if obj:
            self.postprocessing = load_object(obj.get("name"))
            self.postprocessing_args = obj.get("args", tuple())
            self.postprocessing_kwargs = obj.get("kwargs", {})

    def fit_model(self, X, y, classifier_params=None, fit_params=None):
        classifier_params = classifier_params or {}
        fit_params = fit_params or {}
        X_train, _, y_train, _ = train_test_split(X, y)
        auto = AutoSklearnClassifier(**classifier_params)
        auto.fit(X_train, y_train, **fit_params)
        if ("resampling_strategy" in classifier_params
                and classifier_params["resampling_strategy"] == "cv"
                and auto.ensemble_size != 0):
            # X_train, _, y_train, _ = train_test_split(X, y)
            auto.refit(X_train, y_train)
        return auto

    def _process(self, file_path):
        X, y = self.loader.load(file_path)
        for _ in range(self.num_trials):
            logger.info("Starting trial %d", _)
            for hpo in self.hpo:
                logger.info("Trialing with HPO %s", hpo)
                classifier_params, fit_params = self.get_autosklearn_params(
                        file_path)
                classifier_params["get_smac_object_callback"] = (
                                                            self.DICT_HPO_ALG[hpo])
                classifier_params["seed"] = np.random.randint(0, 2 ** 31)
                try:
                    auto = self.fit_model(X, y, classifier_params, fit_params)
                except Exception as e:
                    logger.info("ERROR IN FIT: {}".format(str(e)))
                    continue
                auto.filename = file_path
                logger.info("Model fitted, starting info extraction")
                try:
                    info = self.execute_extractors(auto, X, y)
                except Exception as e:
                    logger.info("Error in info extraction: {}".format(str(e)))
                    continue
                logger.info("Saving extracted information")
                self.save_info(info)

    def execute_extractors(self, auto, X, y):
        dictionary = {}
        for extractor in self.info_extractors["extractors"]:
            logger.info("Extracting info with extractor %s", extractor)
            dictionary.update(extractor(auto, X, y))
        for metric_name, extractor in self.info_extractors["general"].items():
            logger.info("Extracting metric %s", metric_name)
            dictionary[metric_name] = extractor(auto)
        for extractor_dict in self.info_extractors["prediction"]:
            logger.info("Extracting with dict: %s", extractor_dict)
            result_dict = extractor_dict["computation"](
                                    extractor_dict["estimator"](auto), X, y,
                                    extractor_dict["metrics"]
            )
            prefix_dict_keys(result_dict, extractor_dict["prefix"])
            dictionary.update(result_dict)
        return dictionary

    def get_autosklearn_params(self, file_path):
        return extract_autosklearn_params(self.config, file_path)

    def save_info(self, info):
        self.writer.process(info)

    def process(self):
        for f in self.files:
            logger.info("Starting processing off file %s", f)
            self._process(f)
        logger.info("Model generation finished, starting postprocessing")
        if self.postprocessing:
            self.postprocessing(self.config, *self.postprocessing_args,
                                **self.postprocessing_kwargs)


def model_generation(config):
    data_path = config["FEATURE_OUTPUT_PATH"]
    config["MODEL_GENERATION_FILES_TO_LOAD"] = prefix_files(
            config["MODEL_GENERATION_FILES_TO_LOAD"], data_path)
    prefix_autosklean_params_dict(config, data_path)
    mgm = ModelGenerationManager(config)
    mgm.process()
