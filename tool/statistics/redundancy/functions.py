# -*- coding: utf-8 -*-
"""
Created on Tue Jul 14 12:32:42 2020

@author: David
"""
from ..processing import Order


def select_best(results, redundant_values, index):
    '''
    Receives a dictionary whose keys are a tuple with two elements, both
    of them tuples and are values of the descriptive columns of the data, the
    values are instances of Order enum, that determine which one is
    better.

    results is a dictionary whose keys are the metrics being evaluated and
    whose values are other dictionaries with two keys: ranking and
    comparisons.

    ranking is a list of DescriptiveStats order from greater to lower
    comparisons is a dictionary whose keys are 2-tuples whose elements are
    also tuples, which contain the values of the columns being compared. Each
    of these tuples contain a value in redundant_values, apart form values
    of other columns. The values a 2-tuple with pvalue and Order.

    redundant values is a list with the values to be compared

    index is the integer index of the position of the column corresponding to
    the redundant values in the tuples of the keys of results

    This function must return a list with the values of redundant values
    to be eliminated
    '''
    rankings = {}
    results_dicts = {}
    for key, dictionary in results.items():
        rankings[key] = dictionary["ranking"]
        results_dicts[key] = dictionary["comparisons"]
    metric_dicts = dict.fromkeys(results)
    for key in metric_dicts:
        metric_dicts[key] = dict.fromkeys(redundant_values, 0)
    for key, result_dict in results_dicts.items():
        for ikey, (value, order) in result_dict.items():
            if order == Order.LOWER:
                metric_dicts[key][ikey[1][index]] += 1
            elif order == Order.GREATER:
                metric_dicts[key][ikey[0][index]] += 1
    sorted_evals = [sorted(metric_dict, key=lambda x: metric_dict[x])
                    for metric, metric_dict in metric_dicts.items()]
    keys = list(results)
    best_set = set([x[-1] for x, key in zip(sorted_evals, keys)
                    if metric_dicts[key][x[-2]] != metric_dicts[key][x[-1]]])
    if len(best_set) == 1:  # First place in all
        sorted_evals[0].remove(best_set.pop())
        return sorted_evals[0]
    return []
