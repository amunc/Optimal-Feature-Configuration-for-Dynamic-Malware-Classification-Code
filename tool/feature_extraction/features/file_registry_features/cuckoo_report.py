# -*- coding: utf-8 -*-
"""
Created on Tue Jul  7 12:18:00 2020

@author: David
"""

# -*- coding: utf-8 -*-
"""
Created on Tue Jul  7 09:23:39 2020

@author: David
"""


class Summary:
    """Generates summary information."""

    key = "summary"

    def __init__(self):
        self.keys = []
        self.read_keys = []
        self.write_keys = []
        self.delete_keys = []
        self.mutexes = []
        self.files = []
        self.read_files = []
        self.write_files = []
        self.delete_files = []
        self.started_services = []
        self.created_services = []
        self.executed_commands = []
        self.resolved_apis = []

    def get_argument(self, call, argname, strip=False):
        for arg in call["arguments"]:
            if arg == argname:
                if strip:
                    return call["arguments"][arg].strip()
                else:
                    return call["arguments"][arg]
        return None

    def get_raw_argument(self, call, argname):
        for arg in call["arguments"]:
            if arg == argname:
                # return arg["raw_value"]
                return arg["raw_value"]
        return None

    def construct(self, json_data):
        """Generate processes list from streamed calls/processes.
        @return: None.
        """
        processes = json_data['behavior']['processes']
        calls = []
        for p in processes:
            calls += p['calls']
        for call in calls:
            if call["api"].startswith("RegOpenKeyEx"):
                name = self.get_argument(call, "regkey")
                if name and name not in self.keys:
                    self.keys.append(name)
            elif call["api"].startswith("RegSetValue") or call["api"] == "NtSetValueKey":
                name = self.get_argument(call, "regkey")
                if name and name not in self.keys:
                    self.keys.append(name)
                if name and name not in self.write_keys:
                    self.write_keys.append(name)
            elif call["api"] == "NtDeleteValueKey" or call["api"] == "NtDeleteKey" or call["api"].startswith("RegDeleteValue"):
                name = self.get_argument(call, "regkey")
                if name and name not in self.keys:
                    self.keys.append(name)
                if name and name not in self.delete_keys:
                    self.delete_keys.append(name)
            elif call["api"].startswith("RegCreateKeyEx"):
                name = self.get_argument(call, "regkey")
                disposition = self.get_argument(call, "disposition")
                if name and name not in self.keys:
                    self.keys.append(name)
                # if disposition == 1 then we created a new key
                if name and disposition == 1 and name not in self.write_keys:
                    self.write_keys.append(name)
            elif call["api"].startswith("NtOpenKey"):
                name = self.get_argument(call, "regkey")
                if name and name not in self.keys:
                    self.keys.append(name)
            elif call["api"] == "NtCreateKey":
                name = self.get_argument(call, "regkey")
                disposition = self.get_argument(call, "disposition")
                if name and name not in self.keys:
                    self.keys.append(name)
                # if disposition == 1 then we created a new key
                if name and disposition == 1 and name not in self.write_keys:
                    self.write_keys.append(name)
            elif call["api"].startswith("RegQueryValue") or call["api"] == "NtQueryValueKey" or call["api"] == "NtQueryMultipleValueKey":
                name = self.get_argument(call, "regkey")
                if name and name not in self.keys:
                    self.keys.append(name)
                if name and name not in self.read_keys:
                    self.read_keys.append(name)
            elif call["api"].startswith("DeleteFile") or call["api"] == "NtDeleteFile" or call["api"].startswith("RemoveDirectory"):
                filename = (self.get_argument(call, "filepath") or self.get_argument(call, "filepath_r")) or (self.get_argument(call, "dirpath") or self.get_argument(call, "dirpath_r"))
                if filename:
                    if filename not in self.files:
                        self.files.append(filename)
                    if filename not in self.delete_files:
                        self.delete_files.append(filename)
            elif call["api"] == "MoveFileWithProgressW" or call["api"] == "MoveFileWithProgressTransactedW":
                origname = self.get_argument(call, "oldfilepath")
                newname = self.get_argument(call, "newfilepath")
                if origname:
                    if origname not in self.files:
                        self.files.append(origname)
                    if origname not in self.delete_files:
                        self.delete_files.append(origname)
                if newname:
                    if newname not in self.files:
                        self.files.append(newname)
                    if newname not in self.write_files:
                        self.write_files.append(newname)

            elif call["category"] == "file":
                filename = self.get_argument(call, "filepath")
                if not filename:
                    filename = self.get_argument(call, "dirpath")
                srcfilename = self.get_argument(call, "oldfilepath")
                dstfilename = self.get_argument(call, "newfilepath")
                access = None
                accessval = self.get_argument(call, "desired_access")
                if accessval:
                    access = int(accessval, 16)
                if filename:
                    if (access and (access & 0x80000000 or access & 0x10000000
                                    or access & 0x02000000 or access & 0x1)
                            and filename not in self.read_files):
                        self.read_files.append(filename)
                    if (access and (access & 0x40000000 or access & 0x10000000
                                    or access & 0x02000000 or access & 0x6)
                            and filename not in self.write_files):
                        self.write_files.append(filename)
                    if filename not in self.files:
                        self.files.append(filename)
                if srcfilename:
                    if srcfilename not in self.read_files:
                        self.read_files.append(srcfilename)
                    if srcfilename not in self.files:
                        self.files.append(srcfilename)
                if dstfilename:
                    if dstfilename not in self.write_files:
                        self.write_files.append(dstfilename)
                    if dstfilename not in self.files:
                        self.files.append(dstfilename)

    def run(self):
        """Get registry keys, mutexes and files.
        @return: Summary of keys, read keys, written keys, mutexes and files.
        """
        return {"files": self.files, "read_files": self.read_files,
                "write_files": self.write_files,
                "delete_files": self.delete_files, "keys": self.keys,
                "read_keys": self.read_keys, "write_keys": self.write_keys,
                "delete_keys": self.delete_keys}


class Enhanced(object):
    """Generates a more extensive high-level representation than Summary."""

    key = "enhanced"

    def __init__(self, details=False):
        """
        @param details: Also add some (not so relevant) Details to the log
        """
        self.eid = 0
        self.details = details
        self.modules = {}
        self.procedures = {}
        self.events = []

    def _add_procedure(self, mbase, name, base):
        """
        Add a procedure address
        """
        self.procedures[base] = "{0}:{1}".format(
                self._get_loaded_module(mbase), name)

    def _add_loaded_module(self, name, base):
        """
        Add a loaded module to the internal database
        """
        self.modules[base] = name

    def _get_loaded_module(self, base):
        """
        Get the name of a loaded module from the internal db
        """
        return self.modules.get(base, "")

    def _process_call(self, call):
        """ Gets files calls
        @return: information list
        """
        def _load_args(call):
            """
            Load arguments from call
            """
            res = call["arguments"]
            return res

        def _generic_handle_details(self, call, item):
            """
            Generic handling of api calls
            @call: the call dict
            @item: Generic item to process
            """
            event = None
            if call["api"] in item["apis"]:
                args = _load_args(call)
                self.eid += 1

                event = {
                    "event": item["event"],
                    "object": item["object"],
                    "timestamp": call["time"],
                    "eid": self.eid,
                    "data": {}
                }

                for logname, dataname in item["args"]:
                    event["data"][logname] = args.get(dataname)
                    try:
                        d = event['data']['content']
                        if not d:
                            event['data']['content'] = None
                    except KeyError:
                        pass
                return event

        def _generic_handle(self, data, call):
            """Generic handling of api calls."""
            for item in data:
                event = _generic_handle_details(self, call, item)
                if event:
                    return event

            return None

        event = None

        gendat = [
            {
                "event": "write",
                "object": "registry",
                "apis": [
                    "RegSetValueExA",
                    "RegSetValueExW"
                ],
                "args": [
                    ("regkey", "regkey"),
                    ("written", "value")
                ]
            },
            {
                "event": "write",
                "object": "registry",
                "apis": [
                    "RegCreateKeyExA",
                    "RegCreateKeyExW"
                ],
                "args": [
                    ("regkey", "regkey")
                ]
            },
            {
                "event": "read",
                "object": "registry",
                "apis": [
                    "RegQueryValueExA",
                    "RegQueryValueExW",
                ],
                "args": [
                    ("regkey", "regkey"),
                    ("content", "value")
                ]
            },
            {
                "event": "read",
                "object": "registry",
                "apis": [
                    "NtQueryValueKey"
                ],
                "args": [
                    ("regkey", "regkey"),
                    ("content", "value")
                ]
            },
            {
                "event": "delete",
                "object": "registry",
                "apis": [
                    "RegDeleteKeyA",
                    "RegDeleteKeyW",
                    "RegDeleteValueA",
                    "RegDeleteValueW",
                    "NtDeleteValueKey"
                ],
                "args": [
                    ("regkey", "regkey")
                ]
            }
        ]
        event = _generic_handle(self, gendat, call)

        return event

    def construct(self, json_data):
        """Generate processes list from streamed calls/processes.
        @return: None.
        """
        processes = json_data['behavior']['processes']
        calls = []
        for p in processes:
            calls += p['calls']
        for call in calls:
            event = self._process_call(call)
            if event:
                self.events.append(event)

    def run(self):
        """Get registry keys, mutexes and files.
        @return: Summary of keys, mutexes and files.
        """
        return self.events


class FileRegistryInfo:
    def __init__(self):
        self.summary = Summary()
        self.enhanced = Enhanced()

    def construct(self, json_data):
        self.summary.construct(json_data)
        self.enhanced.construct(json_data)
        return self

    def run(self):
        d = self.summary.run()
        e = self.enhanced.run()
        return d, e
