# -*- coding: utf-8 -*-
"""
Created on Tue Jul  7 12:30:03 2020

@author: David
"""
import scapy.all


def payload_size(packet):
    '''
    Computes the payload size of a packet

    Arguments
    ---------------------------
    packet: scapy.packet.Packet
        The packet whose payload size will be computed.

    Returns
    ----------------------------
    payload_size: int
        The size in bytes of the packet's payload
    '''
    # TODO: deal with TLS and such
    last_layer = packet.lastlayer()
    if type(last_layer) == scapy.all.Padding:
        last_layer = packet[packet.layers()[-2]]
    if scapy.layers.http.HTTP in packet:
        return len(packet['HTTP'])
    if type(last_layer) == scapy.all.TCP or type(last_layer) == scapy.all.UDP:
        return 0
    else:  # If is a protocol superior to 4th layer, it's all data
        try:
            return len(last_layer)
        except (TypeError, Exception):  # for some reason TLS packets fail
            return last_layer.deciphered_len or last_layer.wirelen or 0
            # return last_layer.len


def header_size(packet):
    '''
    Computes the header size of a packet. This includes the headers of all
    protocols up to the fourth layer.

    Arguments
    ---------------------------
    packet: scapy.packet.Packet
        The packet whose header size will be computed.

    Returns
    ----------------------------
    payload_size: int
        The size in bytes of the packet's header
    '''
    padding = 0
    if scapy.all.Padding in packet:
        padding = len(packet['Padding'])
    return packet.wirelen - payload_size(packet) - padding


class BaseProcessor(object):
    '''
    Base class for packet processors shouldn't be instantiated.

    subclasses must implement the _process(self, item) method
    '''
    def valid(self, packet):
        '''
        Determines if a packet is accepted to be processed or not.

        Arguments
        -----------------------------
        packet: DirectedPacket.
            The packet to be processed

        Returns
        ----------------------
        valid: boolean
            True if the packet will be processed, False otherwise
        '''
        return True

    def process(self, packet):
        '''
        The main interface of the processor. _proccess does the actual work.

        Arguments
        ------------------------
        packet: DirectedPacket.
            The packet to be processed

        Returns
        --------------------------
        None
        '''
        if not self.valid(packet):
            return
        self._process(packet)

    def _process(self, packet):
        '''
        Process a packet.

        Arguments
        ---------------------
        packet: scapy.packet.Packet

        Returns
        ----------------------
        None
        '''
        raise NotImplementedError

    def return_metrics(self):
        '''
        Returns the computed metrics by this processor

        Returns
        ------------------------
        metrics: dict.
            The computed metrics. keys are the names and values its values.
        '''
        raise NotImplementedError


# The interface is the same, but flow processors receive a Flow object
# instead of a packet in process()
class BaseFlowProcessor(BaseProcessor):
    pass
