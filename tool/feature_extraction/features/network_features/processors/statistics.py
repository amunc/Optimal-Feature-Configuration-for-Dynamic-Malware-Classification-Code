# -*- coding: utf-8 -*-
"""
Created on Tue Jul  7 12:26:57 2020

@author: David
"""
import numpy as np
import itertools
import re
from scipy.special import gamma, psi
from numpy import pi
from sklearn.neighbors import NearestNeighbors


# Stolen from https://gist.github.com/GaelVaroquaux/ead9898bd3c973c40429
def nearest_distances(X, k=1):
    '''
    X = array(N,M)
    N = number of points
    M = number of dimensions
    returns the distance to the kth nearest neighbor for every point in X
    '''
    if X.shape[0] <= k:
        k = X.shape[0]
    knn = NearestNeighbors(n_neighbors=k)
    knn.fit(X)
    d, _ = knn.kneighbors(X)  # the first nearest neighbor is itself
    return d[:, -1]  # returns the distance to the kth nearest neighbor


# Stolen from https://gist.github.com/GaelVaroquaux/ead9898bd3c973c40429
def entropy(X, k=3):
    ''' Returns the entropy of the X.
    Parameters
    ===========
    X : array-like, shape (n_samples, n_features)
        The data the entropy of which is computed
    k : int, optional
        number of nearest neighbors for density estimation
    Notes
    ======
    Kozachenko, L. F. & Leonenko, N. N. 1987 Sample estimate of entropy
    of a random vector. Probl. Inf. Transm. 23, 95-101.
    See also: Evans, D. 2008 A computationally efficient estimator for
    mutual information, Proc. R. Soc. A 464 (2093), 1203-1215.
    and:
    Kraskov A, Stogbauer H, Grassberger P. (2004). Estimating mutual
    information. Phys Rev E 69(6 Pt 2):066138.
    '''

    # Distance to kth nearest neighbor
    r = nearest_distances(X, k)  # squared distances
    n, d = X.shape
    volume_unit_ball = (pi**(.5*d)) / gamma(.5*d + 1)
    '''
    F. Perez-Cruz, (2008). Estimation of Information Theoretic Measures
    for Continuous Random Variables. Advances in Neural Information
    Processing Systems 21 (NIPS). Vancouver (Canada), December.
    return d*mean(log(r))+log(volume_unit_ball)+log(n-1)-log(k)
    '''
    entropy = (d*np.mean(np.log(r + np.finfo(X.dtype).eps))
               + np.log(volume_unit_ball) + psi(n) - psi(k))
    return np.clip(entropy, 0, np.inf)


class SummaryStatistics(object):
    '''
    Class that accumulates values and performs some statistical computations
    over them.

    While not explicitly enforced, the values are expected to be numeric.

    Instance Attributes
    ------------------------------------
    values: list
        List of accumulated values
    '''
    # These methods should return a standard value when there are no values
    overwritten_statistics = ['mean', 'max', 'min', 'std', 'variance',
                              'median', 'third_quartile', 'entropy']

    def __init__(self):
        self.values = []

    def __getattribute__(self, name):
        # If self.values is empty when calling those, return NaN
        if (name in SummaryStatistics.overwritten_statistics
                and not self.values):
            # return lambda: np.nan
            return lambda: 0
        else:
            return object.__getattribute__(self, name)

    def __add__(self, summary):
        new = SummaryStatistics()
        new.add_multiple(self.values)
        new.add_multiple(summary)
        return new

    def add(self, value):
        '''
        Adds a single value.

        Arguments
        --------------------------
        value: object
            The value to add

        Returns
        ----------------------
        None
        '''
        self.values.append(value)

    def add_multiple(self, values):
        '''
        Adds all the values contained in the iterable values.

        Arguments
        --------------------------
        values: iterable
            Contains the values to be added

        Returns
        ----------------------
        None
        '''
        self.values.extend(values)

    def mean(self):
        '''
        Computes the mean of values
        '''
        return np.mean(self.values)

    def max(self):
        '''
        Computes the maximum value
        '''
        return np.max(self.values)

    def min(self):
        '''
        Computes the minimum value
        '''
        return np.min(self.values)

    def std(self):
        '''
        Computes the sample standard deviation of values
        '''
        return np.std(self.values, ddof=1) if len(self.values) > 1 else 0

    def variance(self):
        '''
        Computes the sample variance of values
        '''
        return np.var(self.values, ddof=1) if len(self.values) > 1 else 0

    def sum(self):
        '''
        Computes the sum of values
        '''
        return np.sum(self.values)

    def median(self):
        '''
        Computes the median of values
        '''
        return np.median(self.values)

    def third_quartile(self):
        '''
        Computes the third quartile of values
        '''
        # return np.quantile(self.values, 0.75)
        return np.percentile(self.values, 75)

    def entropy(self):
        '''
        Computes a nearest neighbor entropy estimation of values.
        '''
        vals = np.array(self.values, dtype=np.float).reshape(
                [len(self.values), -1])
        return entropy(vals)

    def count(self):
        '''
        Computes the number of accumulated values
        '''
        return len(self.values)

    @staticmethod
    def metric_names():
        '''
        Produces the names of the method that compute some statistical
        property.

        Returns
        ------------------------------
        metric_names: list<str>
            List of names of the methods that will be returned with
            return_metrics
        '''
        return SummaryStatistics.overwritten_statistics + ['count', 'sum']

    def return_metrics(self):
        '''
        Returns the results of all the methods whose name is registered in
        metric_names()

        Returns
        --------------------------------
        metrics: dict
            A dictionary whose keys are the returned value of metric_names
            and whose values are the return values of the methods corresponding
            to the metric_names
        '''
        return dict(
            [(name, getattr(self, name)()) for name in self.metric_names()]
        )


class Statistics(object):
    '''
    Base class, shouldn't be instantiated.
    Captures statistics from pcaps, both inbound and outbound.

    Class Attributes
    -----------------------------
    returned_metrics: list<string>
        Names of the metrics returned by the return_metrics method

    Instance Attributes
    ----------------------------
    outbound_summary: SummaryStatistics
        Accumulates whatever quantity is processed from outbound packets
    inbound_summary: SummaryStatistics
        Accumulates whatever quantity is processed from inbound packets
    '''
    directions = ['inbound', 'outbound']
    pairs = itertools.product(directions, SummaryStatistics.metric_names())
    # The whole inbound_mean, outbound_max, etc. metrics to be returned.
    returned_metrics = list(map(lambda x: '_'.join(x), pairs))

    def __init__(self):
        self.outbound_summary = SummaryStatistics()
        self.inbound_summary = SummaryStatistics()

    def __getattr__(self, name):
        '''
        This defines a set of virtual attributes named inbound_$metric$ and
        outbound_$metric$, where metric refers to a method of the
        underlying SummaryStatistics object and the prefixes inbound and
        outbound selects which of the summaries is accessed.
        '''
        if not re.match(r'(in|out)bound_.+', name):
            raise AttributeError('%s' % name)
        direction, metric = name.split('_', 1)
        if direction == 'outbound':
            summary = self.outbound_summary
        elif direction == 'inbound':
            summary = self.inbound_summary
        return getattr(summary, metric)

    def return_metrics(self):
        return dict(
            [(name, getattr(self, name)()) for name in self.returned_metrics]
        )
