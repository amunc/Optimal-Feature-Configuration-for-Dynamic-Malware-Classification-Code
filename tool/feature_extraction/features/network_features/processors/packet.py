# -*- coding: utf-8 -*-
"""
Created on Tue Jul  7 12:26:43 2020

@author: David
"""
from .bases import (
        BaseProcessor, header_size, payload_size
)
from .statistics import Statistics, SummaryStatistics
from .. import packetfiltering
from ...utils.dictionary import prefix_dict_keys
import scapy.all
import itertools
import types


class PacketProcessor(BaseProcessor):
    '''
    Class that aglutinates packet processors and combines their results.

    Instance Attributes
    ---------------------------
    processors: tuple<BaseProcessor>
        The processors to be executed
    '''

    def __init__(self, *args):
        self.processors = args

    def _process(self, packet):
        '''
        Simply delivers aech packet to each processor so they do their job
        '''
        for processor in self.processors:
            processor.process(packet)

    def return_metrics(self):
        '''
        Computes the metrics for each processor and merges the results

        Returns
        -----------------------------
        total: dict
            Contains all the metrics computed for each procesor in
            self.processors
        '''
        metrics = []
        for processor in self.processors:
            metrics.append(processor.return_metrics())
        total = {}
        for metric_dict in metrics:
            total.update(metric_dict)
        return total


def packet_processor_list():
    '''
    Returns a list with all the packet processors defined

    Returns
    -----------------------
    packet_processors: list<class>
        List with the classes of all packet processors
    '''
    '''
    return [ByteThroughput,
            ByteStatistics, HeaderStatistics, PayloadStatistics, TTLStatistics,
            HTTPByteStatistics, HTTPHostCount, InterarrivalStatistics,
            TrafficPercentageProcessor, TCPFlagCounterProcessor]
    '''
    return [ByteThroughput, ByteStatistics, HeaderStatistics,
            PayloadStatistics, TTLStatistics, HostCount, HTTPHostCount,
            InterarrivalStatistics, TrafficPercentageProcessor,
            TCPFlagCounterProcessor, TLSSSLStatistics]


def construct_packet_processors():
    '''
    Instantiates the classes returned by packet_processor_list. This is
    used as an argument to the constructor of PacketProcessor.

    Returns
    -----------------------
    packet_processors: list
        List with an instance of each class defined in packet_processor_list.
    '''
    return [cls() for cls in packet_processor_list()]


class HTTPHostCount(BaseProcessor):
    '''
    Counts the number of different hosts connected to via HTTP
    '''
    def __init__(self):
        self.hosts = set()

    def _process(self, packet):
        if packet.forwards:
            self.hosts.add(packet.getlayer(scapy.all.IP).dst)

    def return_metrics(self):
        return {'HTTP_host_count': len(self.hosts)}


class ByteStatistics(Statistics, BaseProcessor):
    '''
    Computes statistics regarding the number of bytes sent and received
    '''
    added_metrics = [
            'outbound_inbound_ratio', 'outbound_inbound_packet_ratio'
    ]
    returned_metrics = Statistics.returned_metrics + added_metrics

    def compute_quantity(self, packet):
        return packet.wirelen

    def _process(self, packet):
        quantity = self.compute_quantity(packet)
        if packet.forwards:
            self.outbound_summary.add(quantity)
        else:
            self.inbound_summary.add(quantity)

    def outbound_inbound_ratio(self):
        '''
        Computes the ratio outbound_bytes / inbound_bytes

        Returns
        ---------------------
        ratio: float
            The ratio of bytes
        '''
        inbound_sum = self.inbound_sum()
        outbound_sum = self.outbound_sum()
        if not inbound_sum and not outbound_sum:
            return -1
        if not inbound_sum:
            # return sys.float_info.max
            return outbound_sum
        return self.outbound_sum() / self.inbound_sum()
        '''
        try:
            return self.outbound_sum() / self.inbound_sum()
        except ZeroDivisionError:
            return np.nan
        '''

    def outbound_inbound_packet_ratio(self):
        '''
        Computes the ratio outbound_packets / inbound_packets

        Returns
        ---------------------
        ratio: float
            The ratio of packets
        '''
        inbound_count = self.inbound_count()
        outbound_count = self.outbound_count()
        if inbound_count == 0 and outbound_count == 0:
            return -1
        if inbound_count == 0:
            # return sys.float_info.max
            return outbound_count
        return self.outbound_count() / self.inbound_count()
        '''
        try:
            return self.outbound_count() / self.inbound_count()
        except ZeroDivisionError:
            return np.nan
        '''

    def return_metrics(self):
        metrics = Statistics.return_metrics(self)
        prefix_dict_keys(metrics, 'bytes_')
        return metrics


class Timestamps(BaseProcessor):
    '''
    A support class that collects timestamps.

    Instance Attributes
    ------------------------------
    inbound_timestamps: list<float>
        Collects the timestamps of inbound packets
    outbound_timestamps: list<float>
        Collects the timestamps of outbound packets
    '''
    def __init__(self):
        self.inbound_timestamps = []
        self.outbound_timestamps = []

    def _process(self, packet):
        timestamp = packet.time
        if packet.forwards:
            self.outbound_timestamps.append(timestamp)
        else:
            self.inbound_timestamps.append(timestamp)

    def outbound_duration(self):
        '''
        Computes the elapsed time from the first outbound timestamp until
        the last

        Returns
        -----------------------
        elapsed: float
            The elapsed time.
        '''
        try:
            return self.outbound_timestamps[-1] - self.outbound_timestamps[0]
        except IndexError:
            return 0

    def inbound_duration(self):
        '''
        Computes the elapsed time from the first inbound timestamp until
        the last

        Returns
        -----------------------
        elapsed: float
            The elapsed time.
        '''
        try:
            return self.inbound_timestamps[-1] - self.inbound_timestamps[0]
        except IndexError:
            return 0


class ByteThroughput(ByteStatistics, Timestamps):
    '''
    Computes the inbound and outbound throughput (per second) of bytes and
    packets
    '''
    returned_metrics = [
            'outbound_throughput', 'inbound_throughput',
            'outbound_packet_throughput', 'inbound_packet_throughput'
    ]

    def __init__(self):
        ByteStatistics.__init__(self)
        Timestamps.__init__(self)

    def _process(self, packet):
        ByteStatistics._process(self, packet)
        Timestamps._process(self, packet)

    def outbound_throughput(self):
        '''
        Computes the throughput of outbound bytes

        Returns
        -------------------
        throughput: float
            The computed throughput
        '''
        outbound_duration = self.outbound_duration()
        if not outbound_duration:
            return 0
        return self.outbound_sum() / self.outbound_duration()
        '''
        try:
            return self.outbound_sum() / self.outbound_duration()
        except ZeroDivisionError:
            return np.nan
        '''

    def inbound_throughput(self):
        '''
        Computes the throughput of inbound bytes

        Returns
        -------------------
        throughput: float
            The computed throughput
        '''
        inbound_duration = self.inbound_duration()
        if not inbound_duration:
            return 0
        return self.inbound_sum() / self.inbound_duration()
        '''
        try:
            return self.inbound_sum() / self.inbound_duration()
        except ZeroDivisionError:
            return np.nan
        '''

    def outbound_packet_throughput(self):
        '''
        Computes the throughput of outbound packets

        Returns
        -------------------
        throughput: float
            The computed throughput
        '''
        outbound_duration = self.outbound_duration()
        if not outbound_duration:
            return 0
        return self.outbound_count() / self.outbound_duration()
        '''
        try:
            return self.outbound_count() / self.outbound_duration()
        except ZeroDivisionError:
            return np.nan
        '''

    def inbound_packet_throughput(self):
        '''
        Computes the throughput of inbound packets

        Returns
        -------------------
        throughput: float
            The computed throughput
        '''
        inbound_duration = self.inbound_duration()
        if not inbound_duration:
            return 0
        return self.inbound_count() / self.inbound_duration()
        '''
        try:
            return self.inbound_count() / self.inbound_duration()
        except ZeroDivisionError:
            return np.nan
        '''


class TTLStatistics(ByteStatistics):
    '''
    Compute statistics related with the TTL of packets
    '''
    copy = Statistics.returned_metrics[:]
    copy.remove('inbound_count')
    copy.remove('outbound_count')
    returned_metrics = copy

    def compute_quantity(self, packet):
        return packet['IP'].ttl

    def return_metrics(self):
        metrics = Statistics.return_metrics(self)
        prefix_dict_keys(metrics, 'ttl_')
        return metrics


class HeaderStatistics(ByteStatistics):
    '''
    Compute statistics related with header size
    '''
    copy = Statistics.returned_metrics[:]
    copy.remove('inbound_count')
    copy.remove('outbound_count')
    returned_metrics = copy

    def compute_quantity(self, packet):
        return header_size(packet)

    def return_metrics(self):
        metrics = Statistics.return_metrics(self)
        prefix_dict_keys(metrics, 'header_size_')
        return metrics


class PayloadStatistics(ByteStatistics):
    '''
    Compute statistics realted with payload size
    '''
    copy = Statistics.returned_metrics[:]
    copy.remove('inbound_count')
    copy.remove('outbound_count')
    returned_metrics = copy

    def compute_quantity(self, packet):
        return payload_size(packet)

    def return_metrics(self):
        metrics = Statistics.return_metrics(self)
        prefix_dict_keys(metrics, 'payload_size_')
        return metrics


class TLSSSLStatistics(ByteStatistics):
    '''
    Compute statistics realted with payload size
    '''
    copy = Statistics.returned_metrics[:]
    returned_metrics = copy

    def valid(self, packet):
        return packetfiltering.is_encrypted(packet)

    def return_metrics(self):
        metrics = Statistics.return_metrics(self)
        prefix_dict_keys(metrics, 'TLS_')
        return metrics


class HostCount(BaseProcessor):
    def __init__(self):
        self.hosts = set()

    def _process(self, packet):
        if packet.forwards:
            self.hosts.add(packet.getlayer(scapy.all.IP).dst)

    def return_metrics(self):
        return {'host_count': len(self.hosts)}


class InterarrivalStatistics(BaseProcessor, Statistics):
    '''
    Compute statistics related with interarrival times of packets
    '''
    copy = Statistics.returned_metrics[:]
    copy.remove('inbound_count')
    copy.remove('outbound_count')
    returned_metrics = copy

    def __init__(self):
        Statistics.__init__(self)
        self.last_outbound = -1
        self.last_inbound = -1
        self.total_summary = SummaryStatistics()
        self.last_total = -1

    def _process(self, packet):
        timestamp = float(packet.time)   # for some reason this returns Decimal
        if packet.forwards:
            if self.last_outbound != -1:
                self.outbound_summary.add(timestamp - self.last_outbound)
            self.last_outbound = timestamp
        else:
            if self.last_inbound != -1:
                self.inbound_summary.add(timestamp - self.last_inbound)
            self.last_inbound = timestamp
        if self.last_total != -1:
            self.total_summary.add(timestamp - self.last_total)
        self.last_total = timestamp

    def return_metrics(self):
        metrics = Statistics.return_metrics(self)
        prefix_dict_keys(metrics, 'interarrival_')
        total_metrics = self.total_summary.return_metrics()
        del total_metrics['count']
        prefix_dict_keys(total_metrics, 'total_interarrival_')
        metrics.update(total_metrics)

        return metrics


class TrafficPercentage(BaseProcessor):
    '''
    Computes the percentage of total traffic which is of a protocol
    '''
    def __init__(self, layer):
        self.filtered = SummaryStatistics()
        self.all = SummaryStatistics()
        self.layer = layer
        self.returned_metrics = [layer.__name__ + '_percentage']

    def valid(self, packet):
        return self.layer in packet if not isinstance(self.layer, types.FunctionType) else self.layer(packet)

    def process(self, packet):
        BaseProcessor.process(self, packet)
        self.all.add(packet.wirelen)

    def _process(self, packet):
        self.filtered.add(packet.wirelen)

    def return_metrics(self):
        sum_all = self.all.sum()
        if not sum_all:
            quantity = 0
        else:
            quantity = self.filtered.sum() / self.all.sum()
        '''
        try:
            # quantity = self.filtered.count() / self.all.count()
            quantity = self.filtered.sum() / self.all.sum()
        except ZeroDivisionError:
            quantity = np.nan
        '''
        return dict([(self.returned_metrics[-1], quantity)])


class TrafficPercentageProcessor(BaseProcessor):
    '''
    Aglutinates several TrafficPercentageProcessor for different protocols
    and combines each one's results.
    '''
    layers = [scapy.all.UDP, scapy.all.TCP, scapy.layers.http.HTTP,
              packetfiltering.is_encrypted]

    def __init__(self):
        self.counters = []
        for layer in TrafficPercentageProcessor.layers:
            self.counters.append(TrafficPercentage(layer))

    def _process(self, packet):
        for counter in self.counters:
            counter.process(packet)

    def return_metrics(self):
        metrics = {}
        for counter in self.counters:
            metrics.update(counter.return_metrics())
        return metrics


def has_TCP_flag(packet, flag):
    '''
    Checks whether a packet has a certain TCP flag.

    Arguments
    ------------------------
    packet: scapy.packet.Packet
        The packet
    flag: str
        The initial letter of the sought flag, capitalized.
    '''
    return scapy.all.TCP in packet and flag in packet['TCP'].flags


class BaseTCPFlagCounter(ByteStatistics):
    '''
    Base class that counts the number of packets with a certain TCP flag.
    '''
    def valid(self, packet):
        return has_TCP_flag(packet, self.flag)

    def __init__(self, flag):
        ByteStatistics.__init__(self)
        self.flag = flag
        name = '_'.join(['TCP', flag, 'flag', 'count'])
        pairs = itertools.product(['inbound', 'outbound'], [name])
        self.returned_metrics = list(map(lambda x: '_'.join(x), pairs))

    def compute_quantity(self, packet):
        return 1

    def return_metrics(self):
        inbound = self.inbound_count()
        outbound = self.outbound_count()

        return dict(zip(self.returned_metrics, [inbound, outbound]))


class TCPFlagCounterProcessor(BaseProcessor):
    '''
    Class that contains several TCPFlagCounter for different flags and
    combines results.
    '''
    def __init__(self):
        self.counters = []
        for flag in scapy.all.TCP.flags.names:
            self.counters.append(BaseTCPFlagCounter(flag))

    def _process(self, packet):
        for counter in self.counters:
            counter.process(packet)

    def return_metrics(self):
        metrics = {}
        for counter in self.counters:
            metrics.update(counter.return_metrics())
        return metrics
