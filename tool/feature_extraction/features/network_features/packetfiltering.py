# -*- coding: utf-8 -*-
"""
Created on Sun Jun 16 08:06:59 2019

@author: David
"""
import scapy.all
try:
    from functools import reduce
except ImportError:
    pass
import operator
import re
import scapy.contrib.igmpv3
scapy.all.load_layer('tls')
scapy.all.load_layer("http")
scapy.all.load_layer('igmpv3')
FILTERED_IP = set()


def filter_from_layers(*layers):
    '''
    Returns a function that receives a single argument: a scapy.packet.Packet
    and returns True if the packet contains any of the layers in *layers

    Arguments
    -----------------------------
    layers: iterable of scapy layers

    Returns
    ---------------------
    layer_filter: function
        Function that expects a scapy.packet.Packet as only argument and
        returns True in any of the elements in layers is contained in the
        packet, False otherwise.
    '''
    def layer_filter(packet):
        return reduce(
            operator.__or__, map(lambda x: x in packet, layers)
        )
    return layer_filter


def UDP(packet):
    '''
    Checks whether the package constains UDP traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains UDP traffic, False otherwise.
    '''
    return packet.haslayer(scapy.all.UDP)


def TCP(packet):
    '''
    Checks whether the package constains TCP traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains TCP traffic, False otherwise.
    '''
    return packet.haslayer(scapy.all.TCP)


def HTTP(packet):
    '''
    Checks whether the package constains HTTP traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains HTTP traffic, False otherwise.
    '''
    return packet.haslayer(scapy.layers.http.HTTP)


def is_ARP(packet):
    '''
    Checks whether the package constains ARP traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains ARP traffic, False otherwise.
    '''
    return packet.haslayer(scapy.all.ARP)


def is_ssdp(packet):
    try:
        return (packet['IP'].dst == '239.255.255.250'
                and packet['UDP'].dport == 1900)
    except IndexError:
        return False


def is_ws_discovery(packet):
    try:
        return (packet['IP'].dst == '239.255.255.250'
                and packet['UDP'].dport == 3702)
    except IndexError:
        return False


def is_LLMR(packet):
    LLMR_layers = [scapy.all.LLMNRQuery, scapy.all.LLMNRResponse]
    return reduce(operator.__or__, map(packet.haslayer, LLMR_layers))


def is_IGMPv3(packet):
    igmpv3_layers = [scapy.contrib.igmpv3.IGMPv3,
                     scapy.contrib.igmpv3.IGMPv3gr,
                     scapy.contrib.igmpv3.IGMPv3mq,
                     scapy.contrib.igmpv3.IGMPv3mr,
                     scapy.contrib.igmpv3.IGMPv3mra]
    return reduce(operator.__or__, map(packet.haslayer, igmpv3_layers))


class IPFilterByDNS:
    ip_pattern = r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'

    def __init__(self, domains):
        self.domains = domains
        self.filtered_ip = set()

    def is_common_dns(self, packet):
        if packet.haslayer(scapy.all.DNS):
            queried = packet['DNS'].qd.qname.decode()
            if queried in self.domains:
                try:
                    response_dns = packet['DNS'].an
                    for i in range(len(response_dns.layers())):
                        response_data = response_dns['DNSRR'][i].rdata
                        if isinstance(response_data, bytes):
                            response_data = response_data.decode()
                        if re.match(self.ip_pattern, response_data):
                            self.filtered_ip.add(response_data)
                except AttributeError:
                    pass
                return True
        return False

    def filter_ip(self, packet):
        '''
        Filters traffic against IPs of well known names.
        FILTERED IP is populated by is_common_DNS, which adds the ip of common
        connections with no relationship with the analyzed sample
        '''
        return (
            not has_no_IP(packet)
            and (
                    packet['IP'].src in self.filtered_ip
                    or packet['IP'].dst in self.filtered_ip
            )
        )

    def __call__(self, packet):
        common = self.is_common_dns(packet)
        filtered_by_ip = self.filter_ip(packet)
        return common or filtered_by_ip


def has_no_IP(packet):
    '''
    Checks whether the package constains ARP traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains ARP traffic, False otherwise.
    '''
    return not packet.haslayer(scapy.all.IP)


def is_NETBIOS(packet):
    '''
    Checks whether the package constains NETBIOS traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains NETBIOS traffic, False otherwise.
    '''
    netbios_layers = [
        scapy.all.NBNSNodeStatusResponseEnd, scapy.all.NBNSNodeStatusResponse,
        scapy.all.NBNSNodeStatusResponseService, scapy.all.NBNSQueryRequest,
        scapy.all.NBNSQueryResponse, scapy.all.NBNSQueryResponseNegative,
        scapy.all.NBNSRequest, scapy.all.NBNSWackResponse,
        scapy.all.NBTDatagram, scapy.all.NBTSession, scapy.all.NetBIOS_DS
        ]
    return reduce(operator.__or__, map(packet.haslayer, netbios_layers))
    # return packet.haslayer(scapy.all.NBNSQueryRequest)


def is_ICMP_redirect(packet):
    '''
    Checks whether the package contains ICMP redirect traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_arp: boolean.
        True if contains ICMP redirect traffic, False otherwise.
    '''
    return scapy.all.IPerror in packet and scapy.all.TCPerror in packet


def is_encrypted(packet):
    '''
    Checks whether the package contains SSL or TLS traffic.

    Arguments
    -------------------------------
    packet: scapy.packet.Packet
        Full packet processed by scapy.

    Returns
    --------------------------------
    is_encrypted: boolean.
        True if contains SSL or TLS traffic, False otherwise.
    '''
    return (scapy.layers.tls.record.TLS in packet
            or scapy.layers.tls.record_sslv2.SSLv2 in packet
            or scapy.layers.tls.record_tls13.TLS13 in packet
            or scapy.layers.tls.record_sslv2.TLS in packet)


def common_domains():
    return [
        'dns.msftncsi.com.', 'teredo.ipv6.microsoft.com.',
        'ipv6.msftncsi.com.', 'settings-win.data.microsoft.com.',
        'nexus.officeapps.live.com.',
        'nexusrules.officeapps.live.com.',
        'ctldl.windowsupdate.com.',
        'settingsfd-geo.trafficmanager.net.',
        'fe2.update.microsoft.com.',
        'acroipm2.adobe.com.', 'ds.download.windowsupdate.com.'
    ]


#def selected_filters():
#    '''
#    Returns the filter functions that will be used in packet_filter.
#
#    The filter functions are expected to identify conditions to
#    exclude packets, so if any of the filter functions used returns True,
#    the packet will be discarded.
#
#    Returns
#    -------------------
#    selected: list<function>
#        Filter functions used
#    '''
#    return [has_no_IP, is_NETBIOS, is_ICMP_redirect,
#            is_LLMR,
#            is_IGMPv3,
#            IPFilterByDNS(common_domains()),
#            is_ssdp,
#            is_ws_discovery,
#            ]


def create_filters():
    ip_filter = IPFilterByDNS(common_domains())

    def selected_filters():
        return [has_no_IP, is_NETBIOS, is_ICMP_redirect, is_LLMR, is_IGMPv3,
                ip_filter, is_ssdp, is_ws_discovery]
    return selected_filters


selected_filters = create_filters()


def packet_filter(packet):
    '''
    Applies the functions in selected_filters to the packet.

    The filter functions are expected to identify conditions to
    exclude packets, so if any of the filter functions used returns True,
    the packet will be discarded.

    Arguments
    -------------------------
    packet: scapy.packet.Packet
        A scapy packet

    Returns
    ----------------------
    accepted: bool
        False if any of the functions in selected_filters returns True; True
        otherwise.

    '''
    filters = selected_filters()
    results = [func(packet) for func in filters]
    return not reduce(operator.__or__, results)
