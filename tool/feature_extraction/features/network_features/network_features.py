# -*- coding: utf-8 -*-
import scapy.all
from .processors.flow import FlowProcessor, construct_flow_processors
from .processors.packet import PacketProcessor, construct_packet_processors
from .directedpacket import DirectedPacket
from .packetfiltering import packet_filter


def infer_source(pcap_path):
    '''
    Returns the estimated IP of source machine.

    The heuristic is that the first source IP to appear will be that of
    the source machine. The reasoning is that since cuckoo works by
    starting a VM for each analysis, it is unlikely that there will be
    IP traffic targeting the machine before it sends something itself.

    Arguments
    ---------------------------------
    pcap_file: str.
        Path of the pcap file to be analized.

    Returns
    ----------------------------------
    source_ip: str
        The estimated source IP
    '''
    for packet in filter_packets(pcap_path):
        if packet.haslayer(scapy.all.IP):
            return packet['IP'].src


def create_processors():
    '''
    Initializes the packet and flow processors that will be used for
    extracting features.

    Returns
    -----------------------
    processors: tuple(<PacketProcessor>, <FlowProcessor>)
        The packet and flow processors
    '''
    pp = PacketProcessor(*construct_packet_processors())
    fp = FlowProcessor(*construct_flow_processors())

    return (pp, fp)


def filter_packets(pcap_path):
    '''
    Returns an iterable with the packets in a pcap. The packets in the pcap
    are filtered using packetfiltering.packet_filter

    Arguments
    ----------------------------
    pcap_path: str
        Path of the pcap file to be processed

    Returns
    -------------------------------
    filtered_packets: generator
        Iterable with the filtered packets
    '''
    # source_ip = ifer_source(pcap_path)
    # DirectedPacket.change_source(source_ip)
    with scapy.all.PcapReader(pcap_path) as reader:
        filtered_packets = filter(packet_filter, reader)
        for filtered in filtered_packets:
            yield filtered


def filter_directed_packets(pcap_path):
    '''
    Returns an iterable with the packets in a pcap. The packets in the pcap
    are filtered using packetfiltering.packet_filter and transformed to
    directedpacket.DirectedPacket.

    Arguments
    ----------------------------
    pcap_path: str
        Path of the pcap file to be processed

    Returns
    -------------------------------
    filtered_packets: generator
        generator with the processed packets
    '''
    source_ip = infer_source(pcap_path)
    DirectedPacket.change_source(source_ip)

    return (DirectedPacket(packet, packet['IP'].src == source_ip)
            for packet in filter_packets(pcap_path))


def process_pcap(pcap_path):
    '''
    Extracts network features from a pcap file.

    Arguments
    ----------------------------
    pcap_path: string.
        Path of the pcap file to process.

    Returns
    ----------------------------
    metrics: dict.
        A dictionary whose keys are the name of the feature and the values
        the values of the corresponding features.
    '''
    # Quizás añadir un filtro adicional que solo capture paquetes con la
    # IP fuente
    processors = create_processors()
    # filtered_packets = map(DirectedPacket, filter_packets(pcap_path))
    filtered_packets = filter_directed_packets(pcap_path)
    for packet in filtered_packets:
        for p in processors:
            p.process(packet)

    metrics = {}
    for p in processors:
        metrics.update(p.return_metrics())
    del filtered_packets
    del processors
    return metrics


def extract_network_features(filtered_packets):
    processors = create_processors()
    for packet in filtered_packets:
        for p in processors:
            p.process(packet)

    metrics = {}
    for p in processors:
        metrics.update(p.return_metrics())
    del processors
    return metrics
