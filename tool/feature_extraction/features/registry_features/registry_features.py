# -*- coding: utf-8 -*-
"""
Created on Fri Jun 21 08:09:40 2019

@author: David
"""
from ..utils.dictionary import prefix_dict_keys


def get_first_write_index(json_data, key_path):
    '''
    Obtains the timestamp of the first write to a registry key.

    Arguments
    ---------------------------
    json_data: dict.
        Data of the JSON report of Cuckoo
    key_path: string
        The path of the key

    Returns
    ---------------------------
    index: int
        The index of the event
    '''
    event_list = json_data['behavior']['enhanced']

    def match(event):
        return (event["object"] == "registry"
                and event['data']["regkey"] == key_path
                and event["event"] == "write")
    # Events are ordered by timestamp, so this is enough
    for index, event in enumerate(event_list):
        if match(event):
            return index
    return None


def is_created(json_data, key_path):
    '''
    Checks whether a key is created.

    As it has been said in get_created_keys, this is a heuristic. The key may
    have been created even if this test fails.

    So, the first time of write of the key is checked, if there is a previous
    read of that key that failed (the data is null) then the key is considered
    to be created. It is pretty brittle, but nothing else comes to mind.

    Arguments
    ---------------------------
    json_data: dict.
        Data of the JSON report of Cuckoo
    key_path: string
        The path of the key

    Returns
    ---------------------------
    created: bool
        True if the key has been created according to the heuristic, False
        otherwise.
    '''
    index = get_first_write_index(json_data, key_path)
    event_list = json_data['behavior']['enhanced'][:index]

    def match(event):
        return (event["object"] == "registry"
                and event['data']["regkey"] == key_path
                and event["event"] == "read"
                and event["data"]["content"] is None)
    for event in event_list:
        if match(event):
            return True
    return False


def get_created_keys(json_data):
    '''
    Tries to heuristically obtain the keys that have been created. The problem
    is that the cuckoo report doesn't say whether a written key existed
    before or not, and neither does the API.

    So, the method consists in searching for read operations before the write,
    and if the write operation failed, then we conclude the key didn't exist
    and therefore was created.

    It may be useless, but for example an alina sample uses registry for
    persistence and seems to check for the autorun key before writing to it so
    perhaps other malware does the same.

    Arguments
    ------------------------------------
    json_data: dict.
        Data of the JSON report of Cuckoo

    Returns
    ---------------------------
    created: list<string>
        Path of the created keys
    '''
    summary = json_data['behavior']['summary']
    # get all written keys
    written = summary['write_keys']
    return [key for key in written if is_created(json_data, key)]


def get_registry_counts(json_data):
    '''
    Returns the counts of registry keys created, written, read and deleted.

    The keys of the returned dictionary are
        'read_keys', 'created_keys', 'written_keys', 'deleted_keys',
        'accessed_keys'

    Arguments
    -----------------------
    json_data: dict.
        Data of the JSON report of Cuckoo

    Returns
    ---------------------------
    counts: dict
        Dictionary with the counts
    '''
    counts = {}
    summary = json_data['behavior']['summary']

    counts['created_keys'] = len(get_created_keys(json_data))
    counts['read_keys'] = len(summary['read_keys'])
    counts['written_keys'] = len(summary['write_keys'])
    counts['deleted_keys'] = len(summary['delete_keys'])
    counts['accessed_keys'] = len(summary['keys'])

    return counts


def get_registry_types():
    '''
    Defines a list with the different datatypes of registry keys.

    Taken from
    https://docs.microsoft.com/en-us/windows/desktop/SysInfo/registry-value-types

    Returns
    ---------------------------------
    types: list<string>
        The list of types
    '''
    return ["REG_BINARY", "REG_DWORD", "REG_DWORD_LITTLE_ENDIAN",
            "REG_DWORD_BIG_ENDIAN", "REG_EXPAND_SZ", "REG_QWORD_LITTLE_ENDIAN",
            "REG_SZ"]


def get_initial_count_type_dict():
    '''
    Creates a dictionary whose keys are the names of data types of
    registry keys and all its values are initialized to 0.

    Returns
    -------------------------
    dictionary: dict.
        The initial dictionary
    '''
    return dict.fromkeys(get_registry_types(), 0)


def get_api_call_list(json_data):
    '''
    Extracts the complete list of api calls in the report. There may several
    processes, so the calls of all of them are chained.

    Arguments
    -----------------------
    json_data: dict.
        Data of the JSON report of Cuckoo

    Returns
    ---------------------------
    api_calls: list<dict>
        The list of apicalls
    '''
    calls = []
    for process in json_data['behavior']['processes']:
        for call in process['calls']:
            calls.append(call)
    return calls


def match_any(string, candidates):
    '''
    Searches in string for any exact ocurrence of any of the elements in
    candidates. If there is a match, returns the matched element.

    The candidates are matched in order, so the first to appear will be
    returned.

    Arguments
    ----------------------------
    string: str
        The string in which to search
    candidates: iterable<str>
        The strings to be sought

    Returns
    -------------------------
    found: str
        The first candidate found in string.
    '''
    for candidate in candidates:
        if candidate in string:
            return candidate
    return None


def get_registry_type_from_call(call_dict, key_path):
    '''
    Returns the type of a registry key from the call dict of a Cuckoo report.

    Arguments
    ----------------------
    call_dict: dict
        An api call dict following Cuckoo format
    key_path: str
        The path of the sought registry key.

    Returns
    -----------------------
    type: str or None
        If there is no type, or the call doesn't contain key_path returns None.
        Otheerwise, it returns the type.
    '''
    call_string = str(call_dict)
    # The conversion to string duplicates backslashes to escape them
    call_string = call_string.replace('\\\\', '\\')
    if key_path in call_string:
        match = match_any(call_string, get_registry_types())
        if match:
            return match
    return None


def get_key_datatype(json_data, key_path):
    '''
    Obtains the datatype of the key.

    Since there is a ton of registry calls and arguments may or may not be
    present, the type is extracted via pattern mathing over the dictionaries
    of api calls. If the call contains key_path, it's a registry call
    and if it contains any of the data types, it means that that is the data
    type of the registry key.

    This implies that datatypes of established keys cannot be changed, which
    may or may not be true. I haven't found any resource that says so, but
    I haven't looked in depth.

    Arguments
    ---------------------------
    json_data: dict.
        Data of the JSON report of Cuckoo
    key_path: string
        The path of the key

    Returns
    ---------------------------
    datatype: string
        The datatype of the key.
    '''
    api_call_list = get_api_call_list(json_data)
    key_type = None
    for call_dict in api_call_list:
        key_type = get_registry_type_from_call(call_dict, key_path)
        if key_type:
            break
    return key_type


def get_registry_counts_by_type(json_data, key_path_list):
    '''
    Computes a dictionary where the keys are the names of data types of
    registry keys and the values the number of registry keys created with that
    type

    Arguments
    -----------------------
    json_data: dict.
        Data of the JSON report of Cuckoo
    key_path_list: iterable<string>
        An iterable which contains the path of the keys to be counted.

    Returns
    ---------------------------
    counts: dict
        Dictionary with the counts
    '''
    counts = get_initial_count_type_dict()
    for key_path in key_path_list:
        key_type = get_key_datatype(json_data, key_path)
        if key_type:
            counts[key_type] += 1
    return counts


def get_counts_by_type(json_data, key_path_list, prefix):
    '''
    Returns a count of created keys by data type

    Arguments
    ------------------------------
    json_data: dict.
        Data of the JSON report of Cuckoo

    Returns
    ------------------------------
    counts: dict
        Dictionary with the counts
    '''
    counts = get_registry_counts_by_type(json_data, key_path_list)
    prefix_dict_keys(counts, prefix)
    return counts


def extract_registry_features(json_data):
    '''
    Returns the registry features extracted from the cuckoo JSON report

    Arguments
    ---------------------------
    json_data: dict
        Data of the JSON report of Cuckoo

    Returns
    ---------------------------
    results: dict
        Dictionary with the extracted features
    '''
    counts = get_registry_counts(json_data)
    counts_written_by_type = get_counts_by_type(
            json_data, json_data['behavior']['summary']['write_keys'],
            "written_"
    )
    counts_created_by_type = get_counts_by_type(
            json_data, get_created_keys(json_data), "created_"
    )

    results = {}
    results.update(counts)
    results.update(counts_written_by_type)
    results.update(counts_created_by_type)

    return results
