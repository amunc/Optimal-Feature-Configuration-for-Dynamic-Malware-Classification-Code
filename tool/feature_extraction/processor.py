# -*- coding: utf-8 -*-
"""
Created on Tue Sep  8 10:56:14 2020

@author: David
"""
from __future__ import annotations
import abc
from typing import Any, List, Tuple, MutableMapping, Optional
import collections.abc
import gc


class BaseProcessor(abc.ABC):
    '''
    Base class for processors used in feature_extraction
    '''
    @abc.abstractmethod
    def process(self, *args, **kwargs):
        pass

    def get_next_args(self, result : Any, *args : Tuple[Any],
                      **kwargs: MutableMapping[str, Any]
                      ) -> Tuple[Tuple[Any], MutableMapping[str, Any]]:
        return (result, ), {}

    @classmethod
    def __subclasshook__(cls, candidate):
        # Only passes check if we test for instance of BaseProcessor
        if cls is BaseProcessor:
            return (hasattr(candidate, "process")
                    and hasattr(candidate, "get_next_args")
            )
        return NotImplemented


class ProcessingStep():
    '''
    Class used to encapsulate individual processors in order to effectively
    chain calls
    '''
    def __init__(self, obj: BaseProcessor,
                 next_steps: Optional[ProcessingStep] = None):
        if not isinstance(obj, BaseProcessor):
            raise TypeError("obj must be a BaseProcessor")
        if not isinstance(next_steps, (type(None), collections.abc.Iterable)):
            raise TypeError("next steps must be an iterable or None")
        self.step = obj
        self.next_steps = next_steps or list()
        for step in self.next_steps:
            if not isinstance(step, self.__class__):
                raise TypeError(
                    "All elements in next_steps must be {}".format(
                        self.__class__)
                )

    def process(self, *args, **kwargs):
        result = self.step.process(*args, **kwargs)
        if isinstance(result, IteratorResult):
            for part in result:
                self.call_next(part, *args, **kwargs)
        else:
            self.call_next(result, *args, **kwargs)
        gc.collect()
        gc.collect()

    def call_next(self, result, *args, **kwargs):
        args, kwargs = self.step.get_next_args(result, *args, *kwargs)
        for next_step in self.next_steps:
            next_step.process(*args, **kwargs)


class IteratorResult:
    '''
    Class to encapsulate iterable results. When a ProcessingStep returns
    an instance of this class, each element is passed to all following
    ProcessingStep, instead of the object being passed directly
    '''
    def __init__(self, iterator):
        if not isinstance(iterator, collections.abc.Iterable):
            raise TypeError("iterator must be an Iterator")
        self.iterator = iter(iterator)

    def __next__(self):
        return next(self.iterator)

    def __iter__(self):
        return self.iterator
