# -*- coding: utf-8 -*-
"""
Created on Tue Sep  1 13:17:37 2020

@author: David
"""
import unittest
import itertools
import inspect
import functools
import re
from typing import Callable, Any, Union, List, Tuple
from tool.utils.general import sized_sequence_and_not_string, is_iterable
__call_info__ = "__call_info__"


class RepeatingTestCase(unittest.TestCase):
    '''
    Class derived from unittest.TestCase that supports the repetition of test
    cases with different parameters.

    Does not work with tests that expect an exception such as assertRaise.

    Also does not work with addTypeEqualityFunc: the registered function does
    not seem to apply.
    '''
    def repeat(self, func: Callable[..., Any],
               arg_values: List[Union[List[Any], Tuple[Any], Any]],
               expected: List[Any],
               comparison: Callable[[Any, Any], Any],
               args: Union[List[str], Tuple[str]] = None,
               msgs: Union[List[str], Tuple[str]] = None) -> None:
        '''
        A convenience function to apply several tests.

        Arguments
        ---------
        func:
            The function to be tested.
            values:
        arg_values:
            The arguments for each call to the function. Each element is a set
            of arguments to be passed to the function.
        expected:
            The expected return values of func when called with arg_values
        comparison:
            A function from the unittest.TestCase assert family of methods.
        args:
            The names of the parameters each element of arguments will bind to.
            If defined the function will be called with dictionary unpacking,
            otherwise sequence unpacking will be applied.
            For example if values = [[1, 2], [3, 4]] and args = ["b", "a"]
            the the function will be called as func(**{"b": 1, "a": 2}) in the
            first call. Otherwise the call would be like func(*values[0])
        func_names:
            The suffixes to apply to the function name. The new functions will
            have a name equal to the original but suffixed with "_<func_name>".
        '''
        arg_values, args, msgs = check_parameterized_args(
                arg_values, args, msgs)
        if len(expected) != len(arg_values):
            raise ValueError("Length of expected and arg_values is different")
        tup = zip(arg_values, expected, args, msgs)
        for arg_val, expect_val, arg_names, func_msg in tup:
            with self.subTest(msg=func_msg, arg_names=arg_names,
                              arg_val=arg_val, expected=expect_val):
                comparison(
                        expect_val,
                        func(*arg_val) if arg_names is None
                        else func(**dict(zip(arg_names, arg_val)))
                )


def check_other_args(obj: Any, target_len: int) -> bool:
    '''
    An auxiliary function to check whether an object is a non-string sequence
    of non-zero length and has a certain length.

    Arguments
    ---------
    obj:
        The object to check

    target_len:
        the length to be compared to

    Returns
    -------
    checked:
        Whether obj satisfies the conditions
    '''
    return sized_sequence_and_not_string(obj) and len(obj) == target_len


def make_tuple(obj: Any) -> Union[Any, Tuple]:
    '''
    Transforms an object to a single element tuple. The transformation will not
    be applied if obj is a non-string list-like.

    Arguments
    ---------
    obj:
        The object to apply the transformation to

    Returns
    -------
    new_obj:
        The original object or a single element tuple containing it.
    '''
    if (not isinstance(obj, tuple)
            and not is_iterable(obj, exclude_dicts=True, exclude_sets=True)):
        return (obj, )
    return obj


def check_parameterized_args(values: List[Union[List[Any], Tuple[Any], Any]],
                             args: Union[List[str], Tuple[str]] = None,
                             func_names: Union[List[str], Tuple[str]] = None):
    '''
    Performs some sanity checks on the inputs of parameterize and
    parameterize_directly. The idea is to ensure that the lengths match and to
    apply certain transformations.

    - Ensures that all elements of values are list-likes in order to be passed
      with unpacking.
    - If func_names is not defined, returns a default numerical naming
    - If args is not defined, return an iterable with the same length as values
      so that they can be zipped together.

    Each element of values that is not a tuple or a list will be make into a
    single element tuple so that it can be passed with unpacking. This implies
    that if you want to pass a list or tuple as an argument, it should be
    embedded in another list or tuple so that unpacking returns it.

    Arguments
    ---------
    values:
        The arguments for each call to the function. Each element is a set of
        arguments to be passed to the function.
    args:
        The names of the parameters each element of arguments will bind to. If
        defined the function will be called with dictionary unpacking,
        otherwise sequence unpacking will be applied.
        For example if values = [[1, 2], [3, 4]] and args = ["b", "a"]
        the the function will be called as func(**{"b": 1, "a": 2}) in the
        first call. Otherwise the call would be like func(*values[0])
    func_names:
        The suffixes to apply to the function name. The new functions will have
        a name equal to the original but suffixed with "_<func_name>".

    Returns
    -------
    values:
        values, conveniently transformed so that all elements are list-likes
    args:
        the orginal if defined, otherwise an iterable with the same length as
        values so that they can be zipped
    func_names:
        the original if defined or a list of equal length to values with
        increasing numbers
    -------
    '''
    values = list(map(make_tuple, values))
    if not sized_sequence_and_not_string(values):
        raise ValueError("values must be a non-string sized")
    len_values = len(values)
    if not all(map(sized_sequence_and_not_string, values)):
        raise ValueError("all values must be non-string sized")
    try:
        len_first = len(next(iter(values)))
    except StopIteration:
        raise ValueError("values is empty")
    if not all(map(lambda x: len(x) == len_first, values)):
        raise ValueError("mismatched length of elements in values")
    if func_names is not None:
        if not check_other_args(func_names, len_values):
            raise ValueError(
              "func_names must be a non string sized with equal len to values")
        # Putting a name with blanks is a bad idea
        func_names = [re.sub("\s", "_", str(x)) for x in func_names]
    else:
        func_names = [str(i) for i in range(len_values)]
    if args is not None:
        if not check_other_args(args, len_first):
            raise ValueError(
            "args must be a non-string sized with equal len to values elems")
    return (values, itertools.repeat(args, len_values), func_names)


def has_self_parameter(func: Callable[..., Any]) -> bool:
    '''
    Checks whether a function has a parameter named "self" as first paramter
    and that parameter is positional only or positional or keyword

    Parameters
    ----------
    func : Callable[..., Any]
        The function whose signature is going to be inspected

    Returns
    -------
    bool
        Whether the function satifies the conditions

    '''
    parameters = inspect.signature(func).parameters
    return (len(parameters) > 0 and list(parameters)[0] == "self"
            and (
                parameters["self"].POSITIONAL_OR_KEYWORD
                or parameters["self"].POSITIONAL_ONLY
            )
    )


def is_method(func: Callable[..., Any]) -> bool:
    '''
    Checks whether a function is a method

    Parameters
    ----------
    func : TYPE
        The function to check

    Returns
    -------
    bool
        Whether the function stifies the conditions

    '''
    return (inspect.ismethod(func) or inspect.ismethoddescriptor(func)
            or has_self_parameter(func))


def parameterize_directly(values: List[Union[List[Any], Tuple[Any], Any]],
                          args: Union[List[str], Tuple[str]] = None,
                          func_names: Union[List[str], Tuple[str]] = None
                          ) -> Callable[..., Callable[..., Any]]:
    '''
    Decorator to be used in combination with ParameterizedTestMeta in order to
    define several test cases derived from a base one. This one does not need
    to interact with ParameterizedTestMeta in order to generate the new tests
    since it uses a frame hack.

    Note that while this will add new functions to the class, it will leave
    the original name set to None, since it is what the original name cannot be
    removed from inside the decorator since it has not been yet assigned: the
    decorator executes before the name binding.

    Arguments
    ---------
    values:
        The arguments for each call to the function. Each element is a set of
        arguments to be passed to the function.
    args:
        The names of the parameters each element of arguments will bind to. If
        defined the function will be called with dictionary unpacking,
        otherwise sequence unpacking will be applied.
        For example if values = [[1, 2], [3, 4]] and args = ["b", "a"]
        the the function will be called as func(**{"b": 1, "a": 2}) in the
        first call. Otherwise the call would be like func(*values[0])
    func_names:
        The suffixes to apply to the function name. The new functions will have
        a name equal to the original but suffixed with "_<func_name>".

    Returns
    -------
    decorator:
        The decorator function to be applied.
    '''
    input_and_expected = zip(
            *check_parameterized_args(values, args, func_names))

    def decorator(func, input_and_expected=input_and_expected):
        # Access the previous frame, which is the frame used on class
        # definition
        frame = inspect.currentframe().f_back
        for val, arg, func_name in input_and_expected:
            partial = (functools.partialmethod if is_method(func)
                       else functools.partial)
            if arg:
                new_f = partial(func, **dict(zip(arg, val)))
            else:
                new_f = partial(func, *val)
            new_name = new_name = '_'.join([func.__name__, func_name])
            # Modify the local names in the frame: which will be the names
            # defined inside the class
            frame.f_locals[new_name] = new_f
    return decorator


def parameterize(values: List[Union[List[Any], Tuple[Any], Any]],
                 args: Union[List[str], Tuple[str]] = None,
                 func_names: Union[List[str], Tuple[str]] = None
                 ) -> Callable[..., Callable[..., Any]]:
    '''
    Decorator to be used in combination with ParameterizedTestMeta in order to
    define several test cases derived from a base one. The original function
    will be eliminated and instead, several new functions will be defined in
    the class, each one implcitly calling the original with the specified
    arguments.

    This decorator simply marks the function with an attribute that
    ParameterizedTestMeta will detect. The attribute contains the input
    arguments and optionally the names of the parameters they are bound to
    and the suffixes for each of the new functions.

    Arguments
    ---------
    values:
        The arguments for each call to the function. Each element is a set of
        arguments to be passed to the function.
    args:
        The names of the parameters each element of arguments will bind to. If
        defined the function will be called with dictionary unpacking,
        otherwise sequence unpacking will be applied.
        For example if values = [[1, 2], [3, 4]] and args = ["b", "a"]
        the the function will be called as func(**{"b": 1, "a": 2}) in the
        first call. Otherwise the call would be like func(*values[0])
    func_names:
        The suffixes to apply to the function name. The new functions will have
        a name equal to the original but suffixed with "_<func_name>".

    Returns
    -------
    decorator:
        The decorator function to be applied.
    '''
    call_info = check_parameterized_args(values, args, func_names)

    def decorator(func):
        setattr(func, __call_info__, call_info)
        return func
    return decorator


class ParameterizedTestMeta(type):
    '''
    Metaclass to be used in combination with parameterize in order to generate
    new test cases for different inputs.

    This metaclass simply checks the TestCase class attributes, finding those
    that have been decorated by parameterize and generating the new functions
    and deleting the original.
    '''
    def __new__(mtcls, classname, bases, attributedict):
        for name, method in tuple(attributedict.items()):
            if hasattr(method, __call_info__):
                del attributedict[name]
                for vals, args, f_name in zip(*getattr(method, __call_info__)):
                    # The use of default parameters is pretty much mandatory
                    # otherwise the closure would take the last value of the
                    # variables method and values instead of the corresponding
                    # to the iteration. However, default values are evaluated
                    # only once at the time of function definition, therefore
                    # it will take the appropriate value
                    if args:
                        new_func = functools.partialmethod(method,
                                                     **dict(zip(args, vals)))
                    else:
                        new_func = functools.partialmethod(method, *vals)
                    new_name = '_'.join([method.__name__, f_name])
                    attributedict[new_name] = new_func
        return type.__new__(mtcls, classname, bases, attributedict)
