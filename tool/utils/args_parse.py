# -*- coding: utf-8 -*-
"""
Created on Tue Jul 28 08:27:56 2020

@author: David
"""

from optparse import Option, OptionParser, make_option, Values
from typing import List, Union, TypeVar, Tuple, Dict, Any
import sys

T = TypeVar("T")

EXECUTION_ARGS = ["extraction", "generation", "statistics"]
CORRESPONDENCE = {"extraction": "FEATURE_EXTRACTION_ENABLED",
                  "generation": "MODEL_GENERATION_ENABLED",
                  "statistics": "STATISTICS_ENABLED"}


def vararg_callback(option: Option, option_str: str,
                    value: Union[T, Tuple[T]], parser: OptionParser) -> None:
    '''
    A callback to get options with a variable naumber of arguments

    Arguments
    ----------------------
    option: optparse.Option
        The option object we are getting arguments for
    option_str: str
        The string to identify the option with
    value: Union[T, Sequence[T]]
        Already catched values for this option. T will be the type specified in
        the option and if it specified nargs is greater than 1 if will be a
        tuple
    parser: OptionParser
        The parser object that is doing the parsing
    '''
    if value is not None:
        raise ValueError(
                "Did not expect any value for option {}".format(option_str))
    vals = []
    num = 0

    '''def is_num(obj):
        try:
            float(obj)
            return True
        except ValueError:
            return False
    '''
    for arg in parser.rargs:
        if arg[:2] == "--" or arg[:1] == '-' or arg in EXECUTION_ARGS:
            break
        #elif is_num(arg):
        #    raise ValueError("option {} must be a string".format(option_str))
        # If an execution arg is found, break
        vals.append(arg)
        num += 1
    del parser.rargs[:num]
    setattr(parser.values, option.dest, vals)


def option_list() -> List[Option]:
    '''
    Returns a list of the accepted command line options. Their dest argument
    corresponds with the setting in settings.py that will be set.
    '''
    return [
        make_option("--data-path", action="store", type="string",
                    dest="BASE_DATA_PATH",
                    help="path of files to extract features from"),
        make_option("--add-paths", action="callback", callback=vararg_callback,
                    dest="ADD_TO_PYTHON_PATH",
                    help='''paths to include in python search to locate
                            custom modules'''),
        make_option("--delete-files", action="store_true",
                    dest="DELETE_FILES_AT_START",
                    help="delete files contained in storage directories"),
        make_option("--keep-files", action="store_false",
                    dest="DELETE_FILES_AT_START",
                    help="do not delete files in storage directories"),
        make_option("--feature-dir", action="store", type="string",
                    dest="FEATURE_OUTPUT_PATH",
                    help="output directory for feature extraction files"),
        make_option("--train-files", action="callback",
                    callback=vararg_callback,
                    dest="MODEL_GENERATION_FILES_TO_LOAD",
                    help="files to load for model generation"),
        make_option("--num-trials", action="store", type="int",
                    dest="NUM_OF_TRIALS",
                    help="number of trials in model generation"),
        make_option("--discard-columns", action="callback",
                    callback=vararg_callback,
                    dest="COLUMNS_TO_DISCARD",
                    help="columns to discard from --train-files"),
        make_option("--target-col", action="store", type="string",
                    dest="TARGET_COL",
                    help="column with data labels in --train-files"),
        make_option("--info-ouput-path", action="store", type="string",
                    dest="INFO_OUTPUT_PATH",
                    help="output directory for model generation"),
        make_option("--base-pvalue", action="store", type="float",
                    dest="BASE_PVALUE",
                    help="base level of significance in statistical tests"),
        make_option("--statistics-input-file", action="store", type="string",
                    dest="STATISTICS_INPUT_FILE"),
        make_option("--data-cols", action="callback", callback=vararg_callback,
                    dest="STATISTICS_DATA_COLUMNS",
                    help='''columns with numerical results in model generation
                    output'''),
        make_option("--descriptive-cols", action="callback",
                    callback=vararg_callback,
                    dest="STATISTICS_DESCRIPTIVE_COLUMNS",
                    help='''columns with categorical data in model generation
                    output to select the best category'''),
        make_option("--statistics-ouput-path", action="store", type="string",
                    dest="STATISTICS_OUTPUT_PATH",
                    help="output path for statistics"),
        make_option("--statistics-column-order", action="callback",
                    callback=vararg_callback, dest="COLUMN_EVALUATION_ORDER",
                    help="evaluation order for elimination of values")
    ]


def create_parser() -> OptionParser:
    '''
    Creates an OptionParser with the options in optiion_list()

    Returns
    -------
    OptionParser
    '''
    return OptionParser(option_list=option_list())


def get_options_and_args(args=sys.argv[1:])->Tuple[Values, Tuple[str]]:
    '''
    Returns the options with their values and remaining command line arguments

    Returns
    -------
    options: Values
        Command line options parsed.
    args: Tuple[str]
        Remaining command line arguments not associated to any option
    '''
    return create_parser().parse_args(args)


def construct_options_dict(options: Values) -> Dict[str, Any]:
    '''
    Returns a dictionary whose keys are strings with the attribute names of
    options and whose values are the option value corresponding to the name.

    Arguments
    ---------
    options: Values
        Read options

    Returns
    -------
    Dict[str, Any]: values in dict format
    '''
    # Just in case Values have items in dir by default, we use set difference
    # so that they are not included
    names = set(dir(options)) - set(dir(Values()))
    values = map(lambda x: getattr(options, x), names)
    return {k: v for k, v in zip(names, values) if v is not None}


def get_options_dict(args=sys.argv[1:]) -> Dict[str, Any]:
    '''
    Completely parses commandline arguments, including execution options, which
    are not associated to any option, and returns a dictionary with them

    Returns
    -------
    : Dict[str, Any]
        The settings passed through command line in dictionary form
    '''
    (options, args) = get_options_and_args(args)
    options_dict = construct_options_dict(options)
    # Initialize to false, so that nothing is executed
    for key in EXECUTION_ARGS:
        options_dict[CORRESPONDENCE[key]] = False
    # Search for execution options
    for arg in args:
        if arg in EXECUTION_ARGS:
            options_dict[CORRESPONDENCE[arg]] = True
    return options_dict


def getcmd_args():
    return get_options_dict()
