import unittest
import unittest.mock
from tool.feature_extraction.processor import (
    BaseProcessor, ProcessingStep, IteratorResult
)

class TestIteratorResult(unittest.TestCase):
    def setUp(self):
        self.value = list(range(10))

    def test_Iteration(self):
        self.assertEqual(self.value, list(IteratorResult(self.value)))

    def testRaise(self):
        self.assertRaises(TypeError, IteratorResult, 12)


class TestProcessingStep(unittest.TestCase):
    def setUp(self):
        self.args = tuple()
        self.kwargs = dict()
        self.return_value = 12
        self.num_instances = 10

        #Setting up mocks
        self.instances = [unittest.mock.MagicMock(spec_set=BaseProcessor)
                          for i in range(self.num_instances)]
        for ins in self.instances:
            ins.get_next_args.return_value = (self.args, self.kwargs)
            ins.process.return_value = self.return_value

        # ProcessingStep with no next steps
        self.empty = ProcessingStep(self.instances[0])

        # ProcessingStep with two next steps
        self.single = ProcessingStep(
            self.instances[0],
            [ProcessingStep(self.instances[1]),
             ProcessingStep(self.instances[2])])

        # ProcessingStep with two next steps, each of which have other steps
        self.base = ProcessingStep(self.instances[0])
        self.base.next_steps = [
            ProcessingStep(
                self.instances[1],
                [ProcessingStep(x) for x in self.instances[3:7]]
            ),
            ProcessingStep(
                self.instances[2],
                [ProcessingStep(x) for x in self.instances[7:]]
                )
        ]

    def test_init(self):
        self.assertRaises(TypeError, ProcessingStep, 12)
        self.assertRaises(TypeError, ProcessingStep, self.instances[0], 15)
        self.assertRaises(TypeError, ProcessingStep, self.instances[0],
                                                    [self.instances[0]])

    def test_call_next_empty(self):
        self.empty.call_next(12)
        self.empty.step.get_next_args.assert_called_once_with(
            12, *self.args, *self.kwargs)

    def test_call_next_single(self):
        self.single.call_next(12)
        self.empty.step.get_next_args.assert_called_once_with(
            12, *self.args, *self.kwargs)
        for next_step in self.single.next_steps:
            with self.subTest(next_step=next_step):
                next_step.step.process.assert_called_once_with(
                    *self.args, *self.kwargs)

    def test_process(self):
        self.base.process(self.return_value)
        self.base.step.process.assert_called_once_with(self.return_value)
        self.base.step.get_next_args.assert_called_once_with(
                self.return_value, self.return_value
        )
        # All set up instances must have their get_next_args and process
        # methods called
        for i, processor_mock in enumerate(self.instances[1:]):
            with self.subTest(
                    i=i, msg="Testing that all instances have been called"):
                processor_mock.get_next_args.assert_called_once_with(
                    self.return_value,
                    *self.args, **self.kwargs)
                processor_mock.process.assert_called_once_with(
                    *self.args, **self.kwargs)