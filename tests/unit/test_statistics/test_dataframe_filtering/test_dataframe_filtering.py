import unittest
import unittest.mock
from tool.statistics.dataframe_filtering.filtering import (
    mask_single, mask_tuple, mask_tuples, mask_tuples_iter,
    construct_mask, construct_boolean_mask, filter_dataframe,
    compute_common_values, compute_common_tuples,
    compute_common_tuples_equal_field
)
from tool.utils.general import is_iterable
import pandas as pd
import numpy as np
import collections
from tool.utils.parameterize_utils import parameterize_directly


values = [[1, 2, 3], [4, 5, 6], [7, 6, 4], [4, 2, 1]]
columns = ["a", "b", "c"]
sample_df = pd.DataFrame(values, columns=columns)


class TestDataframeFiltering(unittest.TestCase):
    def setUp(self):
        self.values = values
        self.columns = columns
        self.sample_df = pd.DataFrame(self.values, columns=self.columns)

    def check_effective_mask(self, df, key, values, mask, exclude):
        # The mask must be a boolean
        self.assertEqual(mask.dtype, np.bool)
        if not isinstance(values, (list, tuple)):
            values = [values]
        selected = df.loc[mask, key]
        if isinstance(key, (list, tuple)) and len(key) == 1:
            key = key[0]
        if isinstance(key, str):
            unique = sample_df[key]
            selected_unique = set(selected)
        else:
            unique = list(sample_df[key].itertuples(name=None, index=False))
            selected_unique = set(selected.itertuples(index=False, name=None))
        dict_unique = collections.Counter(unique)
        if exclude:
            values = list(set(unique) - set(values))
        else:
            # We may select some elements that are not in the dataframe
            # ignore those
            values = {elem for elem in set(values) if elem in set(unique)}
        # the unique values in the selected dataframe must be equal to the
        # unique values in the mask call.
        self.assertEqual(
            set(values), selected_unique
        )
        count_selected = 0
        for val in values:
            count_selected += dict_unique.get(val, 0)
        # the number of values selected must be equal to the number of those
        # values in the original dataframe
        self.assertEqual(mask.sum(), count_selected)

    @parameterize_directly(
        [("b", 2, False), ("b", [2, 5], False), ("b", [2, 5], True),
         ("a", 4, True)]
    )
    def test_mask_single(self, key, values, exclude):
        mask = mask_single(self.sample_df, key, values, exclude)
        self.check_effective_mask(self.sample_df, key, values, mask,
                                         exclude)

    @parameterize_directly(
        [("b", 2, False, pd.DataFrame([[1, 2, 3], [4, 2, 1]], columns=columns)),
         ("b", [2, 5], False, pd.DataFrame([[1, 2, 3], [4, 5, 6], [4, 2, 1]],
                                                             columns=columns)),
         ("b", [2, 5], True, pd.DataFrame([[7, 6, 4]], columns=columns)),
         ("a", 4, True, pd.DataFrame([[1, 2, 3], [7, 6, 4]], columns=columns))]
    )
    def test_mask_single_exact(self, key, values, exclude, expected):
        mask = mask_single(self.sample_df, key, values, exclude)
        self.assertTrue(
            np.all(self.sample_df.loc[mask].values == expected.values)
        )

    @parameterize_directly(
        [(["a", "b"], [(7, 6)], False), (["b", "c"], [(2, 1)], False),
         (["a", "b"], [(7, 6)], True), (["a", "c"], [(4, 1)], True),
         (["c", "b"], [(5, 7)], False)]
    )
    def test_mask_tuple(self, key, values, exclude):
        mask = mask_tuple(self.sample_df, key, values[0], exclude)
        self.check_effective_mask(self.sample_df, key, values, mask,
                                         exclude)

    @parameterize_directly(
        [(["a", "b"], [(7, 6)], False,
          pd.DataFrame([[7, 6, 4]], columns=columns)),
         (["b", "c"], [(2, 1)], False,
          pd.DataFrame([[4, 2, 1]], columns=columns)),
         (["a", "b"], [(7, 6)], True,
          pd.DataFrame([[1, 2, 3], [4, 5, 6], [4, 2, 1]], columns=columns)),
         (["a", "c"], [(4, 1)], True,
          pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 6, 4]], columns=columns)),
         (["c", "b"], [(5, 7)], False, pd.DataFrame(columns=columns))
        ]
    )
    def test_mask_tuple_exact(self, key, values, exclude, expected):
        mask = mask_tuple(self.sample_df, key, values[0], exclude)
        self.assertTrue(
            np.all(self.sample_df.loc[mask].values == expected.values)
        )

    @parameterize_directly(
        [True, False],
        func_names=["exclude", "no_exclude"]
    )
    def test_mask_tuples(self, exclude):
        return_values = [
            np.array([True, False, True, True], dtype=np.bool),
            np.array([True, False, False, False], dtype=np.bool)
        ]
        arguments = (None, [None], [[None], [None]], exclude)
        with unittest.mock.patch(
                "tool.statistics.dataframe_filtering.filtering.mask_tuple"
                ) as m:
            m.side_effect = return_values
            ret = mask_tuples(*arguments)
            self.assertEqual(m.call_count, len(arguments[2]))
            for call in m.call_args_list:
                with self.subTest(call=call):
                    args, kwargs = call
                    self.assertEqual(args, (None, [None], [None], exclude))
            computation_func = np.logical_or if not exclude else np.logical_and
            np.testing.assert_almost_equal(
                ret, computation_func(*return_values))

    @parameterize_directly(
        [
            (pd.DataFrame, ["a", "b"], (["a", "c"], ["j", "k"]), False,
             "tuples"),
            (pd.DataFrame, "a", ("a", "c"), True, "single")
        ],
        args=["df", "columns", "values", "exclude", "expected"]
    )
    @unittest.mock.patch(
        "tool.statistics.dataframe_filtering.filtering.mask_tuples",
        autospec=True)
    @unittest.mock.patch(
        "tool.statistics.dataframe_filtering.filtering.mask_single",
        autospec=True)
    def test_construct_mask(self, single_mock, tuples_mock, df, columns,
                            values, exclude, expected):
        single_mock.return_value = "single"
        tuples_mock.return_value = "tuples"
        if is_iterable(columns):
            columns = list(columns)
        if is_iterable(values):
            values = list(values)
        if expected == single_mock.return_value:
            selected_mock = single_mock
        elif expected == tuples_mock.return_value:
            selected_mock = tuples_mock
        else:
            raise ValueError(
                "Expected value must be 'single' or 'tuples' found {}".format(
                    expected)
            )
        ret = construct_mask(df, columns, values, exclude)
        selected_mock.assert_called_once_with(df, columns, values, exclude)
        self.assertEqual(ret, expected)


    def test_construct_boolean_mask_error(self):
        self.assertRaises(ValueError, construct_boolean_mask,
                          12, None, None, "or")


    @parameterize_directly(
        [
            (pd.DataFrame, {"a":1, "j": 4}, None, "and"),
            (pd.DataFrame, None, {"a":1, "w": 4}, "or")
        ],
        args=["df", "to_include", "to_exclude", "merge"]
    )
    @unittest.mock.patch(
        "tool.statistics.dataframe_filtering.filtering.construct_mask",
        autospec=True)
    def test_construct_boolean_mask(self, construct_mock, df, to_include,
                                    to_exclude, merge):
        return_value = [
            np.array([True, False, True, True], dtype=np.bool),
            np.array([True, False, False, False], dtype=np.bool)
        ]
        construct_mock.side_effect = return_value
        if merge == 'and':
            func = np.logical_and
        elif merge == 'or':
            func = np.logical_or
        if to_include:
            length = len(to_include)
            exclude = False
            arguments = list(to_include.items())
        elif to_exclude:
            length = len(to_exclude)
            exclude = True
            arguments = list(to_exclude.items())
        ret = construct_boolean_mask(df, to_include, to_exclude, merge)
        self.assertEqual(construct_mock.call_count, length)
        for i, (args, kwargs) in enumerate(construct_mock.call_args_list):
            self.assertEqual(args, (df, *arguments[i], exclude))
        np.testing.assert_almost_equal(ret, func(*return_value))

    def test_filter_dataframe_error(self):
        self.assertRaises(ValueError, filter_dataframe, 12, {"1": 12},
                          {"2": 2}, "and")

    @unittest.mock.patch(
        "tool.statistics.dataframe_filtering.filtering.construct_boolean_mask")
    def test_filter_dataframe(self, construct_mock):

        construct_mock.return_value = np.random.randint(
                                  0, 2, self.sample_df.shape[0], dtype=np.bool)
        res = filter_dataframe(self.sample_df, {"a":12}, connective="and")
        np.testing.assert_almost_equal(
            res.values, self.sample_df.loc[construct_mock.return_value].values)



