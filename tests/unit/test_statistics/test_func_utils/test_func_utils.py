import unittest
import unittest.mock
import numpy as np
from tool.statistics.func_utils.func_utils import (
    unequal_lengths, reduce_to_shortest, function_only_has_var_positional_args,
    check_input_lengths_decorator
)
from tool.utils.parameterize_utils import parameterize_directly

class TestFuncUtils(unittest.TestCase):
    def setUp(self):
        self.min_len = 5
        self.greater_than_50 = np.random.random(51)
        self.small = np.random.random(self.min_len)
        self.different_length_arrays = [
            np.random.random(34), self.greater_than_50, self.small
        ]
        self.equal_length_arrays = [self.small] * 5
        self.test_func = lambda *args: sum(map(sum, args))

    @parameterize_directly(
        [
          [[[1, 2, 3], [3, 4, 5]], False],
          [[[1, 2, 3], [4, 5]], True]
        ],
        func_names=["equal", "unequal"]
    )
    def test_unequal_lengths(self, values, expected):
        self.assertEqual(unequal_lengths(*values), expected)

    def test_reduce_to_shortest(self):
        new_arrays = reduce_to_shortest(*self.different_length_arrays)
        for i, new_array in enumerate(new_arrays):
            with self.subTest(i=i, array=new_array):
                self.assertEqual(len(new_array), self.min_len)
                self.assertEqual(
                    np.isin(new_array, self.different_length_arrays[i]).all(),
                    True, msg="Testing that all elements are in the original"
                )

    @parameterize_directly(
        [(lambda *args: 0, True), (lambda a, c, *args: 0, False),
         (lambda a, *, k=13: 0, False)]
    )
    def test_function_only_has_var_positional_args(self, func, expected):
        self.assertEqual(function_only_has_var_positional_args(func), expected)

    @unittest.mock.patch(
    "tool.statistics.func_utils.func_utils.function_only_has_var_positional_args")
    def test_check_input_lengths_decorator_error(self, patched):
        patched.return_value = False
        self.assertRaises(ValueError, check_input_lengths_decorator,
                          lambda x: 0)

    @unittest.mock.patch(
    "tool.statistics.func_utils.func_utils.unequal_lengths")
    @unittest.mock.patch(
    "tool.statistics.func_utils.func_utils.function_only_has_var_positional_args")
    def test_check_input_lengths_decorator_no_reduce(
            self, positional_mock, unequal_length_mock):
        positional_mock.return_value = True
        unequal_length_mock.return_value = False
        input_data = [[1, 2], [3, 4]]

        func = lambda *args: sum(map(sum, args))
        new_func = check_input_lengths_decorator(func)
        res = new_func(*input_data)

        positional_mock.assert_called_once_with(func)
        unequal_length_mock.assert_called_once_with(*input_data)
        self.assertEqual(res, func(*input_data))


    @unittest.mock.patch(
    "tool.statistics.func_utils.func_utils.reduce_to_shortest")
    @unittest.mock.patch(
    "tool.statistics.func_utils.func_utils.unequal_lengths")
    @unittest.mock.patch(
    "tool.statistics.func_utils.func_utils.function_only_has_var_positional_args")
    def test_check_input_lengths_decorator_reduce(
            self, positional_mock, unequal_length_mock, reduce_mock):
        positional_mock.return_value = True
        unequal_length_mock.return_value = True
        reduce_mock.return_value = [[1], [2]]
        input_data = [[1, 2], [3, 4]]

        func = lambda *args: sum(map(sum, args))
        new_func = check_input_lengths_decorator(func)
        res = new_func(*input_data)

        positional_mock.assert_called_once_with(func)
        unequal_length_mock.assert_called_once_with(*input_data)
        reduce_mock.assert_called_once_with(*input_data)
        self.assertEqual(res, func(*reduce_mock.return_value))