# -*- coding: utf-8 -*-
"""
Created on Thu Sep  3 10:31:15 2020

@author: David
"""
import unittest
import unittest.mock
import sys

from tool.utils.initialization import (
    add_to_python_search_path, remove_files, check_directories_existence,
    initialize, get_settings
)
from tool.utils.parameterize_utils import parameterize_directly

class TestInitialization(unittest.TestCase):

    @parameterize_directly(
        [(["asc", "asd"], ), ([], )]
    )
    def test_add_to_python_search_path(self, addition):
        original = sys.path[:]
        add_to_python_search_path(addition)
        self.assertEqual(sys.path, original + addition)

    def test_remove_files_no_removal(self):
        settings = {}
        with unittest.mock.patch(
                "tool.utils.initialization.empty_directory") as m:
            remove_files(settings)
            m.assert_not_called()

    def test_remove_files(self):
        settings = {"DELETE_FILES_AT_START": True,
                    "FEATURE_OUTPUT_PATH": "asdf", "INFO_OUTPUT_PATH": "as",
                    "STATISTICS_OUTPUT_PATH": "asdfg"}
        with unittest.mock.patch(
                "tool.utils.initialization.empty_directory") as m:
            remove_files(settings)
            m.assert_called_once_with(
                [settings["FEATURE_OUTPUT_PATH"], settings["INFO_OUTPUT_PATH"],
                 settings["STATISTICS_OUTPUT_PATH"]]
            )

    def test_check_directories_existence(self):
        settings = {
            "FEATURE_OUTPUT_PATH": "asdf", "INFO_OUTPUT_PATH": "as",
            "STATISTICS_OUTPUT_PATH": "asdfg"}
        with unittest.mock.patch(
                "tool.utils.initialization.create_directory") as m:
            check_directories_existence(settings)
            m.assert_has_calls(
                [
                unittest.mock.call(settings["FEATURE_OUTPUT_PATH"]),
                unittest.mock.call(settings["INFO_OUTPUT_PATH"]),
                unittest.mock.call(settings["STATISTICS_OUTPUT_PATH"])
                ],
                any_order=True
            )
            self.assertEqual(m.call_count, 3)

    def test_initialize(self):
        settings = {"LOG_CONFIG": 12}
        to_patch = ["add_to_python_search_path", "load_log_config",
                    "check_directories_existence", "remove_files"]
        with unittest.mock.patch.multiple(
                "tool.utils.initialization",
                **dict.fromkeys(to_patch, unittest.mock.DEFAULT)) as d:
            initialize(settings)
            d["add_to_python_search_path"].assert_called_once_with([])
            d["load_log_config"].assert_called_once_with(
                settings["LOG_CONFIG"])
            d["check_directories_existence"].assert_called_once_with(settings)
            d["remove_files"].assert_called_once_with(settings)

    def test_get_settings(self):
        return_values = [{"a": 12, "b": 1}, {"b": 2, "c": 5},
                         {"c": 12, "d": 4}]
        to_patch = ["load_default_settings", "load_user_settings",
                    "getcmd_args"]
        patch_dict = {key: unittest.mock.Mock(return_value=value)
                      for key, value in zip(to_patch, return_values)}
        with unittest.mock.patch.multiple(
                "tool.utils.initialization", **patch_dict) as d:
            ret = get_settings()
            self.assertEqual(ret, {"d": 4, "c": 12, "b": 2, "a": 12})
